# Cursor Rules for TinyBigUI

You are developing TinyBigUI, an open-source Material Design 3 React component library with accessibility-first principles.

## âš ï¸ Task Execution Process (MANDATORY)

**This is a learning project. The user wants to understand every change.**

### Rules for Task Execution:

1. **ONE TASK AT A TIME**: Complete exactly one task, then STOP
2. **DETAILED EXPLANATION**: After each task, explain in detail:
   - What files were created/modified
   - Why each change was made
   - What the code does
   - How it fits into the bigger picture
3. **WAIT FOR APPROVAL**: Do NOT proceed to the next task until the user explicitly approves
4. **ASK IF UNCLEAR**: If a task has ambiguity, ask before implementing

### Task Completion Format:

After completing a task, always provide:

```
## âœ… Task X.X Complete: [Task Name]

### What I Did:
- [List of actions taken]

### Files Created/Modified:
- `path/to/file.ts` - [Brief description]

### Detailed Explanation:
[Explain the purpose and implementation details]

### How This Fits In:
[Context about how this connects to other parts]

---

**Ready for next task?** Please review and confirm to proceed.
```

### âŒ NEVER:
- Execute multiple tasks without approval
- Rush through tasks
- Skip explanations
- Assume approval

## ğŸ—ï¸ Component Architecture (CRITICAL)

**ALL components MUST follow the three-layer architecture. NO EXCEPTIONS.**

### Mandatory Three-Layer Architecture:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Layer 3: MD3 Styled Components   â”‚  â† button.tsx
â”‚   â€¢ Uses CVA for variants          â”‚     (Most users use this)
â”‚   â€¢ Wraps headless layer           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Layer 2: Headless Primitives     â”‚  â† button-headless.tsx
â”‚   â€¢ Uses React Aria hooks          â”‚     (Advanced customization)
â”‚   â€¢ Behavior only, no styling      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Layer 1: React Aria Foundation   â”‚  â† useButton, useFocusRing
â”‚   â€¢ Adobe-backed accessibility     â”‚     (Foundation)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Required Files Per Component:

```
component-name/
â”œâ”€â”€ ComponentNameHeadless.tsx    # Layer 2: React Aria wrapper
â”œâ”€â”€ ComponentName.variants.ts    # CVA variant definitions
â”œâ”€â”€ ComponentName.tsx            # Layer 3: MD3 styled
â”œâ”€â”€ ComponentName.types.ts       # TypeScript types
â”œâ”€â”€ ComponentName.test.tsx       # Tests
â”œâ”€â”€ ComponentName.stories.tsx    # Storybook
â””â”€â”€ index.ts                     # Exports
```

### Implementation Rules:

âœ… **MUST DO:**
1. Create headless component using React Aria hooks
2. Define variants using CVA in `.variants.ts`
3. Create styled component that wraps headless + variants
4. Export BOTH headless and styled versions
5. Test all three layers independently

âŒ **NEVER DO:**
1. Skip the headless layer
2. Implement accessibility manually (use React Aria)
3. Use manual class maps instead of CVA
4. Create single-layer components
5. Skip React Aria hooks

### Example Implementation:

```typescript
// 1. Headless (React Aria)
import { useButton } from 'react-aria';

export function ButtonHeadless(props: ButtonProps) {
  const ref = useRef(null);
  const { buttonProps } = useButton(props, ref);
  return <button {...buttonProps} ref={ref} className={props.className} />;
}

// 2. Variants (CVA)
import { cva } from 'class-variance-authority';

export const buttonVariants = cva('base-classes', {
  variants: {
    variant: { filled: '...', outlined: '...' },
    size: { small: '...', medium: '...' },
  },
  defaultVariants: { variant: 'filled', size: 'medium' },
});

// 3. Styled (Combines 1 + 2)
'use client';

export const Button = forwardRef((props, ref) => {
  const { variant, size, className, ...rest } = props;
  return (
    <ButtonHeadless
      {...rest}
      ref={ref}
      className={cn(buttonVariants({ variant, size }), className)}
    />
  );
});
```

### Verification Checklist:

Before completing ANY component, verify:
- [ ] Headless component exists and uses React Aria
- [ ] Variants defined with CVA (not manual class maps)
- [ ] Styled component wraps headless + variants
- [ ] Both headless and styled exported
- [ ] Tests cover all three layers
- [ ] Storybook shows both versions

**If ANY checkbox is unchecked â†’ Component is NOT complete.**

---

## ğŸ” Package Version Checking (CRITICAL)

**ALWAYS check for latest stable package versions via web search, NOT training data.**

### When Adding Dependencies:

1. **NEVER use versions from training data (April 2024) by default**
2. **ALWAYS search web for latest stable versions**:
   ```
   Search: "[package-name] latest stable version npm 2025"
   Example: "vitest latest stable version npm 2025"
   ```
3. **Check official sources**:
   - npm registry (site:npmjs.com)
   - Official documentation
   - GitHub releases
4. **Document version decisions**:
   - Why this version was chosen
   - Any breaking changes noted
   - Compatibility requirements

### Example Process:

```
Task: Add Vitest for testing

âŒ BAD: Use "vitest": "^2.1.8" (from training data)

âœ… GOOD:
1. Search: "vitest latest stable version December 2025"
2. Find: Vitest 4.0.16 is latest
3. Check: Breaking changes from 2.x to 4.x
4. Use: "vitest": "^4.0.16"
5. Document: "Using Vitest 4.x for browser mode, visual regression features"
```

### Critical Packages to Always Check:

- Testing tools: vitest, @testing-library/*, jsdom
- Build tools: vite, tsup, esbuild
- Framework: react, react-dom
- Styling: tailwindcss, @tailwindcss/*
- Type definitions: @types/*

### If Version Info Unavailable:

1. Explicitly tell user you cannot verify latest version
2. Suggest user runs: `pnpm outdated` or `npm outdated`
3. Use conservative version with caret (^) for flexibility
4. Add TODO comment to check version after install

**Remember:** Fresh projects should use latest stable versions unless there's a specific technical reason not to.

## Core Principles

- **Quality over speed**: Build it right, not fast
- **Accessibility first**: WCAG 2.1 AA is non-negotiable
- **MD3 strict adherence**: Follow Material Design 3 specifications exactly
- **TypeScript strict mode**: No `any` types allowed
- **RSC compatible**: Explicit `'use client'` for interactive components

## Tech Stack

- **React**: 18+ with RSC support
- **TypeScript**: Strict mode enabled
- **Tailwind CSS**: v4.x (CSS-first tokens via `@theme`)
- **React Aria**: For accessibility primitives
- **CVA**: For component variant management
- **Vitest + RTL**: For testing
- **Storybook**: For documentation (Next.js primary, Vite secondary)

## ğŸŒ Tailwind CSS v4 Handling (CRITICAL)

**IMPORTANT**: AI training data is from April 2024 (before Tailwind v4 stable release).

**MANDATORY RULE for ANY Tailwind CSS related task**:

1. ğŸ” **ALWAYS search the web first** for current Tailwind CSS v4 documentation
2. âœ… Use latest official docs from tailwindcss.com
3. âœ… Verify syntax, configuration, and best practices are v4-compatible
4. âœ… Check for breaking changes from v3 â†’ v4
5. âŒ NEVER rely solely on training data for Tailwind v4 specifics

**Tasks requiring web search**:
- Installation and setup
- Configuration (CSS `@theme`, PostCSS, etc.)
- CSS-first token integration
- Framework-specific integration (Next.js, Vite, etc.)
- Any `@import`, `@theme`, `@apply` syntax
- Browser requirements and compatibility
- Plugin usage and configuration
- Content scanning/detection mechanisms

**Search terms to use**:
- "Tailwind CSS v4 [specific feature] documentation"
- "Tailwind CSS v4 [framework] setup guide"
- "Tailwind CSS v4 migration from v3"

## ğŸ“š Storybook Handling (CRITICAL)

**IMPORTANT**: AI training data is from April 2024 (Storybook 7.x era). Current project uses Storybook 10.x.

**MANDATORY RULE for ANY Storybook related task**:

1. ğŸ” **ALWAYS search the web first** for current Storybook version documentation
2. âœ… Use latest official docs from storybook.js.org
3. âœ… Verify syntax, configuration, and API are version-compatible
4. âœ… Check for breaking changes between versions (7.x â†’ 8.x â†’ 9.x â†’ 10.x)
5. âŒ NEVER rely solely on training data for Storybook specifics

**Current Version**: Storybook 10.1.11 (as of December 2025)

**Tasks requiring web search**:
- Installation and setup
- Configuration (main.ts, preview.ts, manager.ts)
- Addon installation and configuration
- Story syntax and API (CSF format)
- Testing with @storybook/test or addon-vitest
- Framework integration (React, Vite, Next.js)
- Deployment and build configuration
- Chromatic or visual testing setup

**Search terms to use**:
- "Storybook 10 [specific feature] documentation"
- "Storybook 10 React Vite setup"
- "Storybook 10 addon configuration"
- "Storybook 10 migration guide"

**Version-specific notes**:
- Package structure changed in v10 (some addons consolidated)
- Testing integration improved (addon-vitest, built-in Playwright)
- Configuration syntax may differ from v7/v8
- Some addons don't have v10 versions (e.g., addon-essentials caps at v8)

## Project Structure

```
tinybigui/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ react/          # @tinybigui/react - Components
â”‚   â””â”€â”€ tokens/         # @tinybigui/tokens - Design tokens (CSS)
```

**Component file structure** (REQUIRED for every component):

```
component-name/
â”œâ”€â”€ component-name.tsx              # Main styled component
â”œâ”€â”€ component-name-headless.tsx     # Headless primitive
â”œâ”€â”€ component-name.variants.ts      # CVA variants
â”œâ”€â”€ component-name.types.ts         # TypeScript types
â”œâ”€â”€ component-name.test.tsx         # Tests
â”œâ”€â”€ component-name.stories.tsx      # Storybook
â””â”€â”€ index.ts                        # Public exports
```

## Code Style

### TypeScript

- âœ… MUST use strict mode (no `any`)
- âœ… MUST use explicit types for all props/functions
- âœ… MUST use JSDoc for all public APIs (include @default, @example)
- âœ… MUST use `forwardRef` for components accepting refs
- âœ… MUST use `const` assertions for literal arrays
- âŒ NEVER use default exports
- âŒ NEVER skip type annotations

### React

- âœ… MUST add `'use client'` to all interactive components
- âœ… MUST use Tailwind CSS (never inline styles or CSS-in-JS)
- âœ… MUST use `cn()` utility for className merging
- âœ… MUST destructure props
- âŒ NEVER use default exports
- âŒ NEVER use inline styles

### React Aria Integration

- âœ… MUST use React Aria hooks for all interactive components
- âœ… MUST let React Aria handle accessibility (ARIA, keyboard, focus)
- âŒ NEVER implement keyboard/ARIA logic manually
- âŒ NEVER skip React Aria hooks

Example:
```typescript
'use client'
import { useButton } from 'react-aria'
import { forwardRef, useRef } from 'react'

function ButtonHeadless(props: ButtonProps) {
  const ref = useRef(null)
  const { buttonProps } = useButton(props, ref)
  return <button {...buttonProps} ref={ref} />
}
```

### CVA (Class Variance Authority)

- âœ… MUST use CVA for all component variants
- âœ… MUST define variants in separate `.variants.ts` file
- âœ… MUST export `VariantProps` type
- âœ… MUST provide `defaultVariants`
- âŒ NEVER handle variants with conditional className logic

Example:
```typescript
// button.variants.ts
import { cva, type VariantProps } from 'class-variance-authority'

export const buttonVariants = cva(
  'base-classes',
  {
    variants: {
      variant: {
        filled: 'bg-primary text-on-primary',
        outlined: 'border-2 border-outline',
      },
      size: {
        small: 'h-10 px-4',
        medium: 'h-12 px-6',
      },
    },
    defaultVariants: {
      variant: 'filled',
      size: 'medium',
    },
  }
)

export type ButtonVariants = VariantProps<typeof buttonVariants>
```

## Material Design 3 Rules

### Design Tokens

- âœ… MUST use MD3 design tokens via Tailwind classes (`bg-primary`, `text-on-primary`)
- âœ… MUST follow MD3 specifications exactly
- âœ… MUST use MD3 elevation classes (`shadow-elevation-1`)
- âœ… MUST use MD3 typography classes (`text-headline-large`)
- âŒ NEVER use arbitrary color values (`bg-[#6750a4]`)
- âŒ NEVER deviate from MD3 specs

### Component Variants

- âœ… MUST implement ALL MD3 variants for each component
- âœ… MUST use MD3 naming (e.g., 'filled', 'outlined' NOT 'solid', 'bordered')
- âŒ NEVER create custom variants not in MD3 spec
- âŒ NEVER skip MD3 variants

### Interactions

- âœ… MUST implement MD3 state layers
- âœ… MUST use MD3 motion tokens (`transition-all duration-short2 ease-standard`)
- âœ… MUST implement ripple effect where specified
- âŒ NEVER use custom animations not in MD3

## Accessibility Rules (WCAG 2.1 AA)

- âœ… MUST meet WCAG 2.1 AA minimum (aim for AAA where feasible)
- âœ… MUST ensure 4.5:1 contrast for text, 3:1 for UI components
- âœ… MUST provide accessible labels for all interactive elements
- âœ… MUST support keyboard navigation (Tab, Enter, Space)
- âœ… MUST show visible focus indicators (never remove)
- âœ… MUST let React Aria handle ARIA attributes
- âœ… MUST add `aria-label` for icon-only components
- âœ… MUST use semantic HTML when possible
- âŒ NEVER skip accessibility attributes
- âŒ NEVER rely on color alone for information
- âŒ NEVER create keyboard traps
- âŒ NEVER add redundant ARIA (React Aria handles it)

## Testing Rules

### Test-Driven Development (TDD) - MANDATORY

**ALL components MUST be developed using TDD approach. NO EXCEPTIONS.**

#### TDD Process (RED â†’ GREEN â†’ REFACTOR):

```
1. ğŸ”´ RED: Write failing tests FIRST
   â”œâ”€â”€ Define test cases based on requirements/specs
   â”œâ”€â”€ Write tests that describe expected behavior
   â””â”€â”€ Run tests â†’ All should FAIL (component doesn't exist yet)

2. ğŸŸ¢ GREEN: Write minimum code to make tests pass
   â”œâ”€â”€ Implement just enough to make tests pass
   â”œâ”€â”€ Don't worry about perfection yet
   â””â”€â”€ Run tests â†’ All should PASS

3. ğŸ”µ REFACTOR: Improve code quality
   â”œâ”€â”€ Clean up implementation
   â”œâ”€â”€ Apply DRY principles
   â”œâ”€â”€ Optimize performance
   â””â”€â”€ Run tests â†’ All should STILL PASS
```

#### Implementation Order for Components:

```
1. Write test file FIRST (ComponentName.test.tsx)
   â”œâ”€â”€ Test rendering with default props
   â”œâ”€â”€ Test all variants
   â”œâ”€â”€ Test all states (disabled, loading, etc.)
   â”œâ”€â”€ Test interactions (click, keyboard)
   â”œâ”€â”€ Test accessibility (axe, ARIA attributes)
   â””â”€â”€ Run tests â†’ RED (all failing)

2. Create types (ComponentName.types.ts)
   â””â”€â”€ Define interfaces based on test requirements

3. Create variants (ComponentName.variants.ts)
   â””â”€â”€ Define CVA variants based on test cases

4. Create headless component (ComponentNameHeadless.tsx)
   â””â”€â”€ Implement React Aria integration

5. Create styled component (ComponentName.tsx)
   â””â”€â”€ Wrap headless + CVA variants

6. Run tests â†’ GREEN (all passing)

7. Create Storybook stories (ComponentName.stories.tsx)
   â””â”€â”€ Visual documentation and manual testing

8. Refactor if needed
   â””â”€â”€ Run tests â†’ Still GREEN
```

#### TDD Benefits:

- âœ… Tests define requirements upfront
- âœ… Prevents over-engineering
- âœ… Ensures testable code
- âœ… Catches bugs early
- âœ… Documents behavior through tests
- âœ… Enables confident refactoring

#### Example TDD Flow:

```typescript
// STEP 1: Write test FIRST (IconButton.test.tsx)
describe('IconButton', () => {
  test('renders with aria-label', () => {
    render(<IconButton aria-label="Delete"><IconDelete /></IconButton>)
    expect(screen.getByLabelText('Delete')).toBeInTheDocument()
  })
  
  test('renders standard variant by default', () => {
    render(<IconButton aria-label="Delete"><IconDelete /></IconButton>)
    expect(screen.getByRole('button')).toHaveClass('bg-transparent')
  })
  
  test('renders filled variant', () => {
    render(
      <IconButton aria-label="Delete" variant="filled">
        <IconDelete />
      </IconButton>
    )
    expect(screen.getByRole('button')).toHaveClass('bg-primary')
  })
})

// STEP 2: Run tests â†’ RED (all fail - component doesn't exist)

// STEP 3: Create types (IconButton.types.ts)
export interface IconButtonProps {
  'aria-label': string; // Required
  variant?: 'standard' | 'filled';
  children: React.ReactNode;
}

// STEP 4: Create variants (IconButton.variants.ts)
export const iconButtonVariants = cva('base', {
  variants: {
    variant: {
      standard: 'bg-transparent',
      filled: 'bg-primary',
    },
  },
  defaultVariants: { variant: 'standard' },
})

// STEP 5: Create component (IconButton.tsx)
export const IconButton = ({ variant, children, ...props }: IconButtonProps) => {
  return (
    <button className={iconButtonVariants({ variant })} {...props}>
      {children}
    </button>
  )
}

// STEP 6: Run tests â†’ GREEN (all pass)

// STEP 7: Refactor if needed â†’ Tests still GREEN
```

#### When to Skip TDD:

**NEVER.** TDD is mandatory for all components.

If you find yourself wanting to skip TDD, it's a sign that:
- Requirements aren't clear (clarify first)
- Component is too complex (break it down)
- Tests are hard to write (simplify design)

### Required Tests

Every component MUST have:
1. Rendering tests (default props, all variants)
2. Interaction tests (click, keyboard)
3. Accessibility tests (axe violations)
4. Customization tests (className merging)

Example structure:
```typescript
describe('Button', () => {
  describe('Rendering', () => {
    it('renders with default props', () => { })
    it('renders all variants', () => { })
  })
  
  describe('Interactions', () => {
    it('handles click events', async () => { })
    it('handles keyboard navigation', async () => { })
  })
  
  describe('Accessibility', () => {
    it('has no violations', async () => {
      const { container } = render(<Button>Click</Button>)
      const results = await axe(container)
      expect(results).toHaveNoViolations()
    })
  })
  
  describe('Customization', () => {
    it('merges custom className', () => { })
  })
})
```

- âœ… MUST write tests for every component
- âœ… MUST include axe accessibility tests
- âœ… MUST achieve >90% code coverage
- âœ… MUST test edge cases and error states
- âŒ NEVER skip tests (even for "simple" components)
- âŒ NEVER skip accessibility tests

## Documentation Rules

### Storybook Stories

Every component MUST have:
- `Default` story
- `Variants` story (all MD3 variants)
- `Sizes` story (if applicable)
- `States` story (hover, focus, disabled)
- `WithIcons` story (if applicable)
- `Accessibility` story
- `Interactive` story with play function

- âœ… MUST create all standard stories
- âœ… MUST include accessibility story
- âœ… MUST include interactive tests (play function)
- âŒ NEVER skip Storybook documentation

### JSDoc

```typescript
interface ButtonProps {
  /**
   * The visual style of the button
   * @default 'filled'
   */
  variant?: 'filled' | 'outlined'
  
  /**
   * Handler called when button is pressed
   */
  onPress?: () => void
}
```

- âœ… MUST add JSDoc to all public APIs
- âœ… MUST document @default values
- âœ… MUST include @example where helpful
- âŒ NEVER skip JSDoc for public APIs

## Import/Export Rules

### Import Order

```typescript
// 1. React imports
import { forwardRef } from 'react'

// 2. External libraries
import { useButton } from 'react-aria'
import { cva } from 'class-variance-authority'

// 3. Internal components
import { Icon } from '../icon'

// 4. Internal utilities
import { cn } from '../../utils/cn'

// 5. Types (use `import type`)
import type { ButtonProps } from './button.types'
```

### Exports

- âœ… MUST use named exports only
- âœ… MUST use `export type` for types
- âœ… MUST re-export from `index.ts`
- âŒ NEVER use default exports
- âŒ NEVER export implementation details

## Commit Rules (Conventional Commits)

Format: `type(scope): description`

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `chore`

Examples:
```bash
feat(button): add loading state
fix(textfield): resolve focus ring color
docs(readme): update installation steps
test(checkbox): add keyboard navigation tests
```

- âœ… MUST use conventional commit format
- âœ… MUST include component scope
- âœ… MUST write descriptive messages
- âŒ NEVER use generic messages ("fixes", "update stuff", "wip")

## Forbidden Patterns (NEVER DO)

```typescript
// âŒ Default exports
export default Button

// âŒ any type
function Button(props: any) { }

// âŒ Inline styles
<button style={{ color: 'red' }} />

// âŒ Manual accessibility
<button onClick={() => {}} onKeyDown={(e) => { }} />

// âŒ Arbitrary values for MD3 tokens
<button className="bg-[#6750a4]" />

// âŒ Missing 'use client' for interactive components
export function Button() { } // Missing directive

// âŒ Non-MD3 variants
<Button variant="fancy" /> // Not in MD3 spec

// âŒ Skip tests
// "This component is too simple to test"

// âŒ Skip accessibility
// "We'll add a11y later"
```

## Required Patterns (ALWAYS DO)

```typescript
// âœ… Named exports
export { Button } from './button'

// âœ… Explicit types
interface ButtonProps extends AriaButtonProps { }

// âœ… 'use client' for interactive components
'use client'
export function Button() { }

// âœ… React Aria
const { buttonProps } = useButton(props, ref)

// âœ… CVA for variants
const buttonVariants = cva(...)

// âœ… MD3 design tokens
<button className="bg-primary text-on-primary" />

// âœ… Write tests
describe('Button', () => { })

// âœ… Write Storybook stories
export const Default: Story = { }

// âœ… JSDoc documentation
/** Button component following MD3 */

// âœ… Accessibility first
it('has no a11y violations', async () => { })
```

## Pre-Change Checklist

Before suggesting ANY code change, verify:

1. âœ… Follows monorepo structure?
2. âœ… Uses TypeScript strict mode?
3. âœ… Follows naming conventions (kebab-case files)?
4. âœ… Uses React Aria for accessibility?
5. âœ… Uses CVA for variants?
6. âœ… Follows MD3 specifications?
7. âœ… Includes `'use client'` if needed?
8. âœ… Includes tests (unit + accessibility)?
9. âœ… Includes Storybook stories?
10. âœ… Includes JSDoc?
11. âœ… Follows import/export rules?
12. âœ… Is accessible (WCAG 2.1 AA)?

**If answer is "No" to any â†’ Don't suggest it!**

## ğŸš€ Release Management & Workflow (CRITICAL)

**This project follows a structured release and branch management strategy. ALL development MUST follow this workflow.**

**Reference**: See `learning-docs/strategies/release-strategy.md` for complete details.

### Release Timeline & Milestones

```
v0.1.0 â†’ Phase 1a + 1b (Button, IconButton, FAB, TextField, Checkbox, Switch) â†’ Week 2-3
v0.2.0 â†’ + Phase 2 (Navigation: AppBar, Tabs, Drawer) â†’ Week 5-6
v0.3.0 â†’ + Phase 3 (Feedback: Dialog, Snackbar, Menu) â†’ Week 8-9
v1.0.0 â†’ Stable Release (All phases complete, API frozen) â†’ Week 16+
```

**Current Status**: Phase 1a Complete âœ… (Button, IconButton, FAB)

### Semantic Versioning Rules

**Pre-1.0 (v0.x.x) - Development Phase:**
- `v0.x.0` â†’ New features (minor version bump)
- `v0.x.y` â†’ Bug fixes (patch version bump)
- Breaking changes ALLOWED (document in CHANGELOG)

**Post-1.0 (v1.x.x) - Stable Phase:**
- `v1.0.0` â†’ First stable release (API frozen)
- `v1.x.0` â†’ New features (backward compatible)
- `v1.0.x` â†’ Bug fixes only
- `v2.0.0` â†’ Breaking changes (major version bump)

### Branch Strategy: GitHub Flow + Phase Prefixes

**Primary Branches:**
- **`main`** - Production releases ONLY (protected, tagged)
- **`dev`** - Integration branch (protected, default for PRs)

**Feature Branch Format**: `type/phase-component-description`

**Branch Types & Naming:**

| Type | Format | Example | When to Use |
|------|--------|---------|-------------|
| Feature | `feat/phase-name` | `feat/1b-textfield-component` | New components/features |
| Bug Fix | `fix/description` | `fix/button-disabled-state` | Bug fixes |
| Documentation | `docs/description` | `docs/button-storybook-examples` | Docs only |
| Refactor | `refactor/description` | `refactor/tokens-color-system` | Code refactoring |
| Test | `test/description` | `test/button-accessibility-tests` | Adding tests |
| Chore | `chore/description` | `chore/deps-update-react-aria` | Maintenance |
| Hotfix | `hotfix/vX.X.X-description` | `hotfix/v0.1.1-button-crash` | Emergency fixes |

**Phase Prefixes for Features:**
```
feat/1a-button-component          # Phase 1a: Core Buttons
feat/1b-textfield-component       # Phase 1b: Form Components
feat/2-navigation-drawer          # Phase 2: Navigation
feat/3-feedback-dialog            # Phase 3: Feedback
```

### Mandatory Feature Development Workflow

**EVERY feature/component MUST follow these 8 steps in order:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: Create Feature Branch                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  git checkout dev                                        â”‚
â”‚  git checkout -b feat/1b-textfield-component            â”‚
â”‚  git push -u origin feat/1b-textfield-component         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: Write Tests First (TDD)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Create ComponentName.test.tsx with 50+ tests           â”‚
â”‚  Run tests â†’ All RED (component doesn't exist yet)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: Implement Component (Three-Layer Architecture) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. ComponentName.types.ts - TypeScript types           â”‚
â”‚  2. ComponentName.variants.ts - CVA variants            â”‚
â”‚  3. ComponentNameHeadless.tsx - React Aria layer        â”‚
â”‚  4. ComponentName.tsx - Styled component                â”‚
â”‚  5. index.ts - Exports                                  â”‚
â”‚  Commit after each file with conventional commits       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 4: Add Storybook Stories                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Create ComponentName.stories.tsx                       â”‚
â”‚  All standard stories (Default, Variants, States, etc.) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 5: Run Quality Checks                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  pnpm test        â†’ All GREEN (50+ tests passing)       â”‚
â”‚  pnpm lint        â†’ No errors                           â”‚
â”‚  pnpm typecheck   â†’ No TypeScript errors                â”‚
â”‚  pnpm storybook   â†’ Visual verification                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 6: Commit Changes (Conventional Commits)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  git add .                                              â”‚
â”‚  git commit -m "feat(textfield): implement TextField"   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 7: Create Task Completion Documentation           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Create docs/phase-X/task-X.X-component-name.md        â”‚
â”‚  Document: implementation, bugs fixed, learnings        â”‚
â”‚  Commit: "docs(textfield): add task completion doc"    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 8: Push & Prepare for PR                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  git push origin feat/1b-textfield-component            â”‚
â”‚  Provide PR template for GitHub                         â”‚
â”‚  Include: title, description, checklist, screenshots    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### AI Assistant Behavioral Rules

**MUST DO for every component/feature:**

1. âœ… **Before Starting**: Suggest creating feature branch with proper naming
2. âœ… **During Development**: Make multiple small commits with conventional format
3. âœ… **After Each File**: Suggest committing with descriptive message
4. âœ… **Quality Gates**: Run test â†’ lint â†’ typecheck before final commit
5. âœ… **Documentation**: Create task completion doc after component done
6. âœ… **Progress Tracking**: Show current phase/milestone status
7. âœ… **PR Preparation**: Provide complete PR template when ready to push

**Example AI Response Pattern:**

```markdown
User: "Let's implement TextField"

AI Response:
"Perfect! TextField is the first component of Phase 1b, part of our v0.1.0 milestone.

ğŸ“ Current Progress:
âœ… Phase 1a Complete: Button, IconButton, FAB
ğŸ”„ Phase 1b In Progress: TextField (starting), Checkbox (pending), Switch (pending)
ğŸ¯ Milestone: v0.1.0 (Week 3)

Let's follow our 8-step workflow:

**STEP 1: Create Feature Branch**
```bash
git checkout dev
git checkout -b feat/1b-textfield-component
git push -u origin feat/1b-textfield-component
```

Ready to proceed? I'll start by writing comprehensive tests (TDD approach)."
```

**NEVER DO:**
- âŒ Start work without creating a feature branch
- âŒ Work directly on `main` or `dev`
- âŒ Skip creating task completion documentation
- âŒ Forget to track progress toward milestone
- âŒ Use non-conventional commit messages
- âŒ Skip quality checks before committing

### Commit Message Format (Conventional Commits)

**Format**: `type(scope): description`

**Types:**
- `feat` - New feature or component
- `fix` - Bug fix
- `docs` - Documentation only
- `test` - Adding or updating tests
- `refactor` - Code refactoring
- `style` - Code formatting (no logic change)
- `chore` - Maintenance tasks
- `perf` - Performance improvements
- `ci` - CI/CD changes
- `build` - Build system changes
- `revert` - Revert previous commit

**Scope**: Component name or area (lowercase)

**Examples:**
```bash
# Good commits
feat(textfield): implement TextField component
feat(textfield): add validation support
fix(button): resolve disabled state styling
test(iconbutton): add keyboard navigation tests
docs(fab): add storybook stories
refactor(tokens): reorganize color system
chore(deps): update react-aria to v3.30.0

# Bad commits (NEVER USE)
feat: add stuff
fix: fix bug
update
WIP
asdf
fixes
```

### Quality Gate Checklist

**Before ANY commit, verify:**
- [ ] All tests passing (`pnpm test`)
- [ ] No linter errors (`pnpm lint`)
- [ ] No TypeScript errors (`pnpm typecheck`)
- [ ] Code follows three-layer architecture
- [ ] Uses React Aria for accessibility
- [ ] Uses CVA for variants
- [ ] MD3 specification compliant
- [ ] 85%+ test coverage maintained

**Before ANY push, additionally verify:**
- [ ] All commits use conventional format
- [ ] Task completion documentation created
- [ ] Storybook stories added and verified
- [ ] Ready for code review

### Pull Request Template

**When pushing feature branch, provide this PR template:**

```markdown
## ğŸ¯ What does this PR do?

[Brief description]

## ğŸ“‹ Changes

- [ ] ComponentName.tsx - Main styled component
- [ ] ComponentNameHeadless.tsx - Headless primitive
- [ ] ComponentName.variants.ts - CVA variants
- [ ] ComponentName.types.ts - TypeScript types
- [ ] ComponentName.test.tsx - Unit tests (XX tests)
- [ ] ComponentName.stories.tsx - Storybook stories
- [ ] task-X.X-component-name.md - Documentation

## ğŸ§ª Testing

- [ ] All existing tests pass
- [ ] XX new tests added
- [ ] Test coverage maintained at 85%+
- [ ] Manual testing in Storybook completed

## ğŸ“¸ Screenshots / Demo

[Add Storybook screenshots]

## âœ… Checklist

- [ ] Tests written first (TDD)
- [ ] All tests passing
- [ ] Linter passes
- [ ] TypeScript strict mode passes
- [ ] Storybook stories added
- [ ] Three-layer architecture followed
- [ ] React Aria used for accessibility
- [ ] MD3 specification compliant
- [ ] Conventional commits used
- [ ] Documentation created

## ğŸ”— Related

Part of Phase 1b - v0.1.0 milestone
[Link to component specification if applicable]
```

### Phase Completion Documentation

**After completing each phase, create phase summary:**

Create: `learning-docs/phase-X/phase-X-completion.md`

Include:
- Overall achievements
- All components implemented
- Test coverage statistics
- Learnings and challenges
- Next steps

**Example:**
```markdown
# Phase 1a Completion Summary

## ğŸ‰ Overview
Phase 1a (Core Buttons) complete! All three button components implemented.

## âœ… Completed Components
1. Button - 53 tests passing
2. IconButton - 49 tests passing  
3. FAB - 51 tests passing

## ğŸ“Š Metrics
- Total Tests: 153
- Test Coverage: 91.2%
- Time: 2 weeks

## ğŸš€ Next Steps
Phase 1b - Form Components (TextField, Checkbox, Switch)
Target: v0.1.0 release after Phase 1b
```

### Release Process (When Ready)

**At release milestones (e.g., v0.1.0 after Phase 1b):**

AI should guide through:
1. Version bump with Changesets or manual
2. CHANGELOG.md update
3. Create release branch (`release/v0.1.0`)
4. Final quality checks
5. Merge to `main` (no squash)
6. Tag release (`git tag -a v0.1.0`)
7. GitHub release creation
8. NPM publishing
9. Sync `dev` with `main`
10. Announce release

**AI should ask**: "Phase 1b complete! Ready to start the v0.1.0 release process?"

### Progress Tracking Format

**ALWAYS include progress context when starting or completing work:**

```
ğŸ“ Current Progress:
âœ… Phase 1a: Button âœ… IconButton âœ… FAB âœ…
ğŸ”„ Phase 1b: TextField ğŸ”„ Checkbox â¬œ Switch â¬œ
â¬œ Phase 2: Not started
ğŸ¯ Next Milestone: v0.1.0 (after Phase 1b completion)
```

### Workflow Example: Complete Feature Implementation

**User**: "Let's implement TextField"

**AI**:
```markdown
Perfect! Let's implement TextField component for Phase 1b.

ğŸ“ **Current Status:**
âœ… Phase 1a Complete: Button, IconButton, FAB
ğŸ”„ Phase 1b In Progress: TextField (starting)
ğŸ¯ Milestone: v0.1.0 (Week 3)

---

### STEP 1: Create Feature Branch

git checkout dev
git checkout -b feat/1b-textfield-component
git push -u origin feat/1b-textfield-component

[Branch created! âœ…]

### STEP 2: Write Tests First (TDD)

I'll create TextField.test.tsx with comprehensive tests...

[Creates 52 tests covering all functionality]
[Runs tests â†’ All RED âœ…]

git add packages/react/src/components/TextField/TextField.test.tsx
git commit -m "test(textfield): add 52 unit tests for TextField"

### STEP 3: Implement Component

**3.1 - Types**
[Creates TextField.types.ts]

git add packages/react/src/components/TextField/TextField.types.ts
git commit -m "feat(textfield): add TypeScript types and interfaces"

**3.2 - CVA Variants**
[Creates TextField.variants.ts]

git add packages/react/src/components/TextField/TextField.variants.ts
git commit -m "feat(textfield): add CVA variants"

**3.3 - Headless Primitive**
[Creates TextFieldHeadless.tsx using React Aria]

git add packages/react/src/components/TextField/TextFieldHeadless.tsx
git commit -m "feat(textfield): implement headless primitive with React Aria"

**3.4 - Styled Component**
[Creates TextField.tsx]

git add packages/react/src/components/TextField/TextField.tsx
git commit -m "feat(textfield): implement styled TextField component"

**3.5 - Exports**
[Updates index.ts]

git add packages/react/src/components/TextField/index.ts
git add packages/react/src/components/index.ts
git commit -m "feat(textfield): add component exports"

[Runs tests â†’ All GREEN! âœ… 52/52 passing]

### STEP 4: Add Storybook Stories

[Creates TextField.stories.tsx]

git add packages/react/src/components/TextField/TextField.stories.tsx
git commit -m "docs(textfield): add Storybook stories"

### STEP 5: Quality Checks

Running quality gates...
âœ… pnpm test - All 52 tests passing
âœ… pnpm lint - No errors
âœ… pnpm typecheck - No TypeScript errors
âœ… Storybook - Visually verified

### STEP 6: Create Documentation

[Creates learning-docs/phase-1/task-1.4-textfield-implementation.md]

git add learning-docs/phase-1/task-1.4-textfield-implementation.md
git commit -m "docs(textfield): add task completion documentation"

### STEP 7: Push & Prepare PR

git push origin feat/1b-textfield-component

âœ… TextField implementation complete!

ğŸ“Š **Summary:**
- 52 tests (all passing)
- 5 component files created
- Test coverage: 89.3%
- Storybook stories: 7

ğŸ“ **Updated Progress:**
âœ… Phase 1a: Button âœ… IconButton âœ… FAB âœ…
ğŸ”„ Phase 1b: TextField âœ… Checkbox â¬œ Switch â¬œ
ğŸ¯ Next: Checkbox component

---

**Ready to create PR?** Here's the template:

[Provides complete PR template]
```

### Context Reminders

**At the START of each session working on the project:**

```
Welcome back! Here's where we are:

ğŸ“ Current Status:
- Phase 1a: Complete âœ… (Button, IconButton, FAB)
- Phase 1b: In Progress (TextField âœ…, Checkbox â¬œ, Switch â¬œ)
- Current branch: feat/1b-checkbox-component

ğŸ¯ Next Milestone: v0.1.0 (after Phase 1b)
ğŸ“š Reference: learning-docs/strategies/release-strategy.md

What would you like to work on?
```

**When COMPLETING a phase:**

```
ğŸ‰ Phase 1b Complete!

All components implemented:
âœ… TextField (52 tests)
âœ… Checkbox (48 tests)
âœ… Switch (45 tests)

ğŸ“Š Phase 1b Stats:
- Total: 145 tests
- Coverage: 88.7%
- Time: 1 week

ğŸš€ Ready for v0.1.0 Release!

According to our release strategy, this completes the requirements for v0.1.0 
(Phase 1a + 1b = Core Buttons + Form Components).

Should we proceed with the release process?
```

### Key Principles

1. **Branch Discipline**: Never work directly on `main` or `dev`
2. **Conventional Commits**: Every commit follows the format
3. **Quality First**: All checks pass before pushing
4. **Documentation Always**: Task completion docs are mandatory
5. **Progress Visibility**: Always show context and progress
6. **Release Readiness**: Track toward milestones
7. **Workflow Adherence**: Follow 8-step process for every feature

---

## Reference Priority

When answering questions, consult in this order:

1. Strategy docs (`learning-docs/strategies/` folder) - **Release & workflow decisions**
2. Material Design 3 specs (m3.material.io)
3. React Aria docs (react-spectrum.adobe.com/react-aria)
4. WCAG guidelines (w3.org/WAI/WCAG21)
5. General best practices

## Core Philosophy

**When in doubt, prioritize: Accessibility > Consistency > Convenience**

All code must be:
- âœ… Consistent across the project
- âœ… Meeting quality standards
- âœ… Accessible (never compromised)
- âœ… Following MD3 specifications
- âœ… Providing excellent DX
- âœ… Maintainable long-term
- âœ… **Following release & branch strategy** (NEW)

