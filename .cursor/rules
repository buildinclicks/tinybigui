# Cursor Rules for TinyBigUI

You are developing TinyBigUI, an open-source Material Design 3 React component library with accessibility-first principles.

## âš ï¸ Task Execution Process (MANDATORY)

**This is a learning project. The user wants to understand every change.**

### Rules for Task Execution:

1. **ONE TASK AT A TIME**: Complete exactly one task, then STOP
2. **DETAILED EXPLANATION**: After each task, explain in detail:
   - What files were created/modified
   - Why each change was made
   - What the code does
   - How it fits into the bigger picture
3. **WAIT FOR APPROVAL**: Do NOT proceed to the next task until the user explicitly approves
4. **ASK IF UNCLEAR**: If a task has ambiguity, ask before implementing

### Task Completion Format:

After completing a task, always provide:

```
## âœ… Task X.X Complete: [Task Name]

### What I Did:
- [List of actions taken]

### Files Created/Modified:
- `path/to/file.ts` - [Brief description]

### Detailed Explanation:
[Explain the purpose and implementation details]

### How This Fits In:
[Context about how this connects to other parts]

---

**Ready for next task?** Please review and confirm to proceed.
```

### âŒ NEVER:
- Execute multiple tasks without approval
- Rush through tasks
- Skip explanations
- Assume approval

## ğŸ—ï¸ Component Architecture (CRITICAL)

**ALL components MUST follow the three-layer architecture. NO EXCEPTIONS.**

### Mandatory Three-Layer Architecture:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Layer 3: MD3 Styled Components   â”‚  â† button.tsx
â”‚   â€¢ Uses CVA for variants          â”‚     (Most users use this)
â”‚   â€¢ Wraps headless layer           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Layer 2: Headless Primitives     â”‚  â† button-headless.tsx
â”‚   â€¢ Uses React Aria hooks          â”‚     (Advanced customization)
â”‚   â€¢ Behavior only, no styling      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Layer 1: React Aria Foundation   â”‚  â† useButton, useFocusRing
â”‚   â€¢ Adobe-backed accessibility     â”‚     (Foundation)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Required Files Per Component:

```
component-name/
â”œâ”€â”€ ComponentNameHeadless.tsx    # Layer 2: React Aria wrapper
â”œâ”€â”€ ComponentName.variants.ts    # CVA variant definitions
â”œâ”€â”€ ComponentName.tsx            # Layer 3: MD3 styled
â”œâ”€â”€ ComponentName.types.ts       # TypeScript types
â”œâ”€â”€ ComponentName.test.tsx       # Tests
â”œâ”€â”€ ComponentName.stories.tsx    # Storybook
â””â”€â”€ index.ts                     # Exports
```

### Implementation Rules:

âœ… **MUST DO:**
1. Create headless component using React Aria hooks
2. Define variants using CVA in `.variants.ts`
3. Create styled component that wraps headless + variants
4. Export BOTH headless and styled versions
5. Test all three layers independently

âŒ **NEVER DO:**
1. Skip the headless layer
2. Implement accessibility manually (use React Aria)
3. Use manual class maps instead of CVA
4. Create single-layer components
5. Skip React Aria hooks

### Example Implementation:

```typescript
// 1. Headless (React Aria)
import { useButton } from 'react-aria';

export function ButtonHeadless(props: ButtonProps) {
  const ref = useRef(null);
  const { buttonProps } = useButton(props, ref);
  return <button {...buttonProps} ref={ref} className={props.className} />;
}

// 2. Variants (CVA)
import { cva } from 'class-variance-authority';

export const buttonVariants = cva('base-classes', {
  variants: {
    variant: { filled: '...', outlined: '...' },
    size: { small: '...', medium: '...' },
  },
  defaultVariants: { variant: 'filled', size: 'medium' },
});

// 3. Styled (Combines 1 + 2)
'use client';

export const Button = forwardRef((props, ref) => {
  const { variant, size, className, ...rest } = props;
  return (
    <ButtonHeadless
      {...rest}
      ref={ref}
      className={cn(buttonVariants({ variant, size }), className)}
    />
  );
});
```

### Verification Checklist:

Before completing ANY component, verify:
- [ ] Headless component exists and uses React Aria
- [ ] Variants defined with CVA (not manual class maps)
- [ ] Styled component wraps headless + variants
- [ ] Both headless and styled exported
- [ ] Tests cover all three layers
- [ ] Storybook shows both versions

**If ANY checkbox is unchecked â†’ Component is NOT complete.**

---

## ğŸ” Package Version Checking (CRITICAL)

**ALWAYS check for latest stable package versions via web search, NOT training data.**

### When Adding Dependencies:

1. **NEVER use versions from training data (April 2024) by default**
2. **ALWAYS search web for latest stable versions**:
   ```
   Search: "[package-name] latest stable version npm 2025"
   Example: "vitest latest stable version npm 2025"
   ```
3. **Check official sources**:
   - npm registry (site:npmjs.com)
   - Official documentation
   - GitHub releases
4. **Document version decisions**:
   - Why this version was chosen
   - Any breaking changes noted
   - Compatibility requirements

### Example Process:

```
Task: Add Vitest for testing

âŒ BAD: Use "vitest": "^2.1.8" (from training data)

âœ… GOOD:
1. Search: "vitest latest stable version December 2025"
2. Find: Vitest 4.0.16 is latest
3. Check: Breaking changes from 2.x to 4.x
4. Use: "vitest": "^4.0.16"
5. Document: "Using Vitest 4.x for browser mode, visual regression features"
```

### Critical Packages to Always Check:

- Testing tools: vitest, @testing-library/*, jsdom
- Build tools: vite, tsup, esbuild
- Framework: react, react-dom
- Styling: tailwindcss, @tailwindcss/*
- Type definitions: @types/*

### If Version Info Unavailable:

1. Explicitly tell user you cannot verify latest version
2. Suggest user runs: `pnpm outdated` or `npm outdated`
3. Use conservative version with caret (^) for flexibility
4. Add TODO comment to check version after install

**Remember:** Fresh projects should use latest stable versions unless there's a specific technical reason not to.

## Core Principles

- **Quality over speed**: Build it right, not fast
- **Accessibility first**: WCAG 2.1 AA is non-negotiable
- **MD3 strict adherence**: Follow Material Design 3 specifications exactly
- **TypeScript strict mode**: No `any` types allowed
- **RSC compatible**: Explicit `'use client'` for interactive components

## Tech Stack

- **React**: 18+ with RSC support
- **TypeScript**: Strict mode enabled
- **Tailwind CSS**: v4.x (CSS-first tokens via `@theme`)
- **React Aria**: For accessibility primitives
- **CVA**: For component variant management
- **Vitest + RTL**: For testing
- **Storybook**: For documentation (Next.js primary, Vite secondary)

## ğŸŒ Tailwind CSS v4 Handling (CRITICAL)

**IMPORTANT**: AI training data is from April 2024 (before Tailwind v4 stable release).

**MANDATORY RULE for ANY Tailwind CSS related task**:

1. ğŸ” **ALWAYS search the web first** for current Tailwind CSS v4 documentation
2. âœ… Use latest official docs from tailwindcss.com
3. âœ… Verify syntax, configuration, and best practices are v4-compatible
4. âœ… Check for breaking changes from v3 â†’ v4
5. âŒ NEVER rely solely on training data for Tailwind v4 specifics

**Tasks requiring web search**:
- Installation and setup
- Configuration (CSS `@theme`, PostCSS, etc.)
- CSS-first token integration
- Framework-specific integration (Next.js, Vite, etc.)
- Any `@import`, `@theme`, `@apply` syntax
- Browser requirements and compatibility
- Plugin usage and configuration
- Content scanning/detection mechanisms

**Search terms to use**:
- "Tailwind CSS v4 [specific feature] documentation"
- "Tailwind CSS v4 [framework] setup guide"
- "Tailwind CSS v4 migration from v3"

## ğŸ“š Storybook Handling (CRITICAL)

**IMPORTANT**: AI training data is from April 2024 (Storybook 7.x era). Current project uses Storybook 10.x.

**MANDATORY RULE for ANY Storybook related task**:

1. ğŸ” **ALWAYS search the web first** for current Storybook version documentation
2. âœ… Use latest official docs from storybook.js.org
3. âœ… Verify syntax, configuration, and API are version-compatible
4. âœ… Check for breaking changes between versions (7.x â†’ 8.x â†’ 9.x â†’ 10.x)
5. âŒ NEVER rely solely on training data for Storybook specifics

**Current Version**: Storybook 10.1.11 (as of December 2025)

**Tasks requiring web search**:
- Installation and setup
- Configuration (main.ts, preview.ts, manager.ts)
- Addon installation and configuration
- Story syntax and API (CSF format)
- Testing with @storybook/test or addon-vitest
- Framework integration (React, Vite, Next.js)
- Deployment and build configuration
- Chromatic or visual testing setup

**Search terms to use**:
- "Storybook 10 [specific feature] documentation"
- "Storybook 10 React Vite setup"
- "Storybook 10 addon configuration"
- "Storybook 10 migration guide"

**Version-specific notes**:
- Package structure changed in v10 (some addons consolidated)
- Testing integration improved (addon-vitest, built-in Playwright)
- Configuration syntax may differ from v7/v8
- Some addons don't have v10 versions (e.g., addon-essentials caps at v8)

## Project Structure

```
tinybigui/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ react/          # @tinybigui/react - Components
â”‚   â””â”€â”€ tokens/         # @tinybigui/tokens - Design tokens (CSS)
```

**Component file structure** (REQUIRED for every component):

```
component-name/
â”œâ”€â”€ component-name.tsx              # Main styled component
â”œâ”€â”€ component-name-headless.tsx     # Headless primitive
â”œâ”€â”€ component-name.variants.ts      # CVA variants
â”œâ”€â”€ component-name.types.ts         # TypeScript types
â”œâ”€â”€ component-name.test.tsx         # Tests
â”œâ”€â”€ component-name.stories.tsx      # Storybook
â””â”€â”€ index.ts                        # Public exports
```

## Code Style

### TypeScript

- âœ… MUST use strict mode (no `any`)
- âœ… MUST use explicit types for all props/functions
- âœ… MUST use JSDoc for all public APIs (include @default, @example)
- âœ… MUST use `forwardRef` for components accepting refs
- âœ… MUST use `const` assertions for literal arrays
- âŒ NEVER use default exports
- âŒ NEVER skip type annotations

### React

- âœ… MUST add `'use client'` to all interactive components
- âœ… MUST use Tailwind CSS (never inline styles or CSS-in-JS)
- âœ… MUST use `cn()` utility for className merging
- âœ… MUST destructure props
- âŒ NEVER use default exports
- âŒ NEVER use inline styles

### React Aria Integration

- âœ… MUST use React Aria hooks for all interactive components
- âœ… MUST let React Aria handle accessibility (ARIA, keyboard, focus)
- âŒ NEVER implement keyboard/ARIA logic manually
- âŒ NEVER skip React Aria hooks

Example:
```typescript
'use client'
import { useButton } from 'react-aria'
import { forwardRef, useRef } from 'react'

function ButtonHeadless(props: ButtonProps) {
  const ref = useRef(null)
  const { buttonProps } = useButton(props, ref)
  return <button {...buttonProps} ref={ref} />
}
```

### CVA (Class Variance Authority)

- âœ… MUST use CVA for all component variants
- âœ… MUST define variants in separate `.variants.ts` file
- âœ… MUST export `VariantProps` type
- âœ… MUST provide `defaultVariants`
- âŒ NEVER handle variants with conditional className logic

Example:
```typescript
// button.variants.ts
import { cva, type VariantProps } from 'class-variance-authority'

export const buttonVariants = cva(
  'base-classes',
  {
    variants: {
      variant: {
        filled: 'bg-primary text-on-primary',
        outlined: 'border-2 border-outline',
      },
      size: {
        small: 'h-10 px-4',
        medium: 'h-12 px-6',
      },
    },
    defaultVariants: {
      variant: 'filled',
      size: 'medium',
    },
  }
)

export type ButtonVariants = VariantProps<typeof buttonVariants>
```

## Material Design 3 Rules

### Design Tokens

- âœ… MUST use MD3 design tokens via Tailwind classes (`bg-primary`, `text-on-primary`)
- âœ… MUST follow MD3 specifications exactly
- âœ… MUST use MD3 elevation classes (`shadow-elevation-1`)
- âœ… MUST use MD3 typography classes (`text-headline-large`)
- âŒ NEVER use arbitrary color values (`bg-[#6750a4]`)
- âŒ NEVER deviate from MD3 specs

### Component Variants

- âœ… MUST implement ALL MD3 variants for each component
- âœ… MUST use MD3 naming (e.g., 'filled', 'outlined' NOT 'solid', 'bordered')
- âŒ NEVER create custom variants not in MD3 spec
- âŒ NEVER skip MD3 variants

### Interactions

- âœ… MUST implement MD3 state layers
- âœ… MUST use MD3 motion tokens (`transition-all duration-short2 ease-standard`)
- âœ… MUST implement ripple effect where specified
- âŒ NEVER use custom animations not in MD3

## Accessibility Rules (WCAG 2.1 AA)

- âœ… MUST meet WCAG 2.1 AA minimum (aim for AAA where feasible)
- âœ… MUST ensure 4.5:1 contrast for text, 3:1 for UI components
- âœ… MUST provide accessible labels for all interactive elements
- âœ… MUST support keyboard navigation (Tab, Enter, Space)
- âœ… MUST show visible focus indicators (never remove)
- âœ… MUST let React Aria handle ARIA attributes
- âœ… MUST add `aria-label` for icon-only components
- âœ… MUST use semantic HTML when possible
- âŒ NEVER skip accessibility attributes
- âŒ NEVER rely on color alone for information
- âŒ NEVER create keyboard traps
- âŒ NEVER add redundant ARIA (React Aria handles it)

## Testing Rules

### Test-Driven Development (TDD) - MANDATORY

**ALL components MUST be developed using TDD approach. NO EXCEPTIONS.**

#### TDD Process (RED â†’ GREEN â†’ REFACTOR):

```
1. ğŸ”´ RED: Write failing tests FIRST
   â”œâ”€â”€ Define test cases based on requirements/specs
   â”œâ”€â”€ Write tests that describe expected behavior
   â””â”€â”€ Run tests â†’ All should FAIL (component doesn't exist yet)

2. ğŸŸ¢ GREEN: Write minimum code to make tests pass
   â”œâ”€â”€ Implement just enough to make tests pass
   â”œâ”€â”€ Don't worry about perfection yet
   â””â”€â”€ Run tests â†’ All should PASS

3. ğŸ”µ REFACTOR: Improve code quality
   â”œâ”€â”€ Clean up implementation
   â”œâ”€â”€ Apply DRY principles
   â”œâ”€â”€ Optimize performance
   â””â”€â”€ Run tests â†’ All should STILL PASS
```

#### Implementation Order for Components:

```
1. Write test file FIRST (ComponentName.test.tsx)
   â”œâ”€â”€ Test rendering with default props
   â”œâ”€â”€ Test all variants
   â”œâ”€â”€ Test all states (disabled, loading, etc.)
   â”œâ”€â”€ Test interactions (click, keyboard)
   â”œâ”€â”€ Test accessibility (axe, ARIA attributes)
   â””â”€â”€ Run tests â†’ RED (all failing)

2. Create types (ComponentName.types.ts)
   â””â”€â”€ Define interfaces based on test requirements

3. Create variants (ComponentName.variants.ts)
   â””â”€â”€ Define CVA variants based on test cases

4. Create headless component (ComponentNameHeadless.tsx)
   â””â”€â”€ Implement React Aria integration

5. Create styled component (ComponentName.tsx)
   â””â”€â”€ Wrap headless + CVA variants

6. Run tests â†’ GREEN (all passing)

7. Create Storybook stories (ComponentName.stories.tsx)
   â””â”€â”€ Visual documentation and manual testing

8. Refactor if needed
   â””â”€â”€ Run tests â†’ Still GREEN
```

#### TDD Benefits:

- âœ… Tests define requirements upfront
- âœ… Prevents over-engineering
- âœ… Ensures testable code
- âœ… Catches bugs early
- âœ… Documents behavior through tests
- âœ… Enables confident refactoring

#### Example TDD Flow:

```typescript
// STEP 1: Write test FIRST (IconButton.test.tsx)
describe('IconButton', () => {
  test('renders with aria-label', () => {
    render(<IconButton aria-label="Delete"><IconDelete /></IconButton>)
    expect(screen.getByLabelText('Delete')).toBeInTheDocument()
  })
  
  test('renders standard variant by default', () => {
    render(<IconButton aria-label="Delete"><IconDelete /></IconButton>)
    expect(screen.getByRole('button')).toHaveClass('bg-transparent')
  })
  
  test('renders filled variant', () => {
    render(
      <IconButton aria-label="Delete" variant="filled">
        <IconDelete />
      </IconButton>
    )
    expect(screen.getByRole('button')).toHaveClass('bg-primary')
  })
})

// STEP 2: Run tests â†’ RED (all fail - component doesn't exist)

// STEP 3: Create types (IconButton.types.ts)
export interface IconButtonProps {
  'aria-label': string; // Required
  variant?: 'standard' | 'filled';
  children: React.ReactNode;
}

// STEP 4: Create variants (IconButton.variants.ts)
export const iconButtonVariants = cva('base', {
  variants: {
    variant: {
      standard: 'bg-transparent',
      filled: 'bg-primary',
    },
  },
  defaultVariants: { variant: 'standard' },
})

// STEP 5: Create component (IconButton.tsx)
export const IconButton = ({ variant, children, ...props }: IconButtonProps) => {
  return (
    <button className={iconButtonVariants({ variant })} {...props}>
      {children}
    </button>
  )
}

// STEP 6: Run tests â†’ GREEN (all pass)

// STEP 7: Refactor if needed â†’ Tests still GREEN
```

#### When to Skip TDD:

**NEVER.** TDD is mandatory for all components.

If you find yourself wanting to skip TDD, it's a sign that:
- Requirements aren't clear (clarify first)
- Component is too complex (break it down)
- Tests are hard to write (simplify design)

### Required Tests

Every component MUST have:
1. Rendering tests (default props, all variants)
2. Interaction tests (click, keyboard)
3. Accessibility tests (axe violations)
4. Customization tests (className merging)

Example structure:
```typescript
describe('Button', () => {
  describe('Rendering', () => {
    it('renders with default props', () => { })
    it('renders all variants', () => { })
  })
  
  describe('Interactions', () => {
    it('handles click events', async () => { })
    it('handles keyboard navigation', async () => { })
  })
  
  describe('Accessibility', () => {
    it('has no violations', async () => {
      const { container } = render(<Button>Click</Button>)
      const results = await axe(container)
      expect(results).toHaveNoViolations()
    })
  })
  
  describe('Customization', () => {
    it('merges custom className', () => { })
  })
})
```

- âœ… MUST write tests for every component
- âœ… MUST include axe accessibility tests
- âœ… MUST achieve >90% code coverage
- âœ… MUST test edge cases and error states
- âŒ NEVER skip tests (even for "simple" components)
- âŒ NEVER skip accessibility tests

## Documentation Rules

### Storybook Stories

Every component MUST have:
- `Default` story
- `Variants` story (all MD3 variants)
- `Sizes` story (if applicable)
- `States` story (hover, focus, disabled)
- `WithIcons` story (if applicable)
- `Accessibility` story
- `Interactive` story with play function

- âœ… MUST create all standard stories
- âœ… MUST include accessibility story
- âœ… MUST include interactive tests (play function)
- âŒ NEVER skip Storybook documentation

### JSDoc

```typescript
interface ButtonProps {
  /**
   * The visual style of the button
   * @default 'filled'
   */
  variant?: 'filled' | 'outlined'
  
  /**
   * Handler called when button is pressed
   */
  onPress?: () => void
}
```

- âœ… MUST add JSDoc to all public APIs
- âœ… MUST document @default values
- âœ… MUST include @example where helpful
- âŒ NEVER skip JSDoc for public APIs

## Import/Export Rules

### Import Order

```typescript
// 1. React imports
import { forwardRef } from 'react'

// 2. External libraries
import { useButton } from 'react-aria'
import { cva } from 'class-variance-authority'

// 3. Internal components
import { Icon } from '../icon'

// 4. Internal utilities
import { cn } from '../../utils/cn'

// 5. Types (use `import type`)
import type { ButtonProps } from './button.types'
```

### Exports

- âœ… MUST use named exports only
- âœ… MUST use `export type` for types
- âœ… MUST re-export from `index.ts`
- âŒ NEVER use default exports
- âŒ NEVER export implementation details

## Commit Rules (Conventional Commits)

Format: `type(scope): description`

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `chore`

Examples:
```bash
feat(button): add loading state
fix(textfield): resolve focus ring color
docs(readme): update installation steps
test(checkbox): add keyboard navigation tests
```

- âœ… MUST use conventional commit format
- âœ… MUST include component scope
- âœ… MUST write descriptive messages
- âŒ NEVER use generic messages ("fixes", "update stuff", "wip")

## Forbidden Patterns (NEVER DO)

```typescript
// âŒ Default exports
export default Button

// âŒ any type
function Button(props: any) { }

// âŒ Inline styles
<button style={{ color: 'red' }} />

// âŒ Manual accessibility
<button onClick={() => {}} onKeyDown={(e) => { }} />

// âŒ Arbitrary values for MD3 tokens
<button className="bg-[#6750a4]" />

// âŒ Missing 'use client' for interactive components
export function Button() { } // Missing directive

// âŒ Non-MD3 variants
<Button variant="fancy" /> // Not in MD3 spec

// âŒ Skip tests
// "This component is too simple to test"

// âŒ Skip accessibility
// "We'll add a11y later"
```

## Required Patterns (ALWAYS DO)

```typescript
// âœ… Named exports
export { Button } from './button'

// âœ… Explicit types
interface ButtonProps extends AriaButtonProps { }

// âœ… 'use client' for interactive components
'use client'
export function Button() { }

// âœ… React Aria
const { buttonProps } = useButton(props, ref)

// âœ… CVA for variants
const buttonVariants = cva(...)

// âœ… MD3 design tokens
<button className="bg-primary text-on-primary" />

// âœ… Write tests
describe('Button', () => { })

// âœ… Write Storybook stories
export const Default: Story = { }

// âœ… JSDoc documentation
/** Button component following MD3 */

// âœ… Accessibility first
it('has no a11y violations', async () => { })
```

## Pre-Change Checklist

Before suggesting ANY code change, verify:

1. âœ… Follows monorepo structure?
2. âœ… Uses TypeScript strict mode?
3. âœ… Follows naming conventions (kebab-case files)?
4. âœ… Uses React Aria for accessibility?
5. âœ… Uses CVA for variants?
6. âœ… Follows MD3 specifications?
7. âœ… Includes `'use client'` if needed?
8. âœ… Includes tests (unit + accessibility)?
9. âœ… Includes Storybook stories?
10. âœ… Includes JSDoc?
11. âœ… Follows import/export rules?
12. âœ… Is accessible (WCAG 2.1 AA)?

**If answer is "No" to any â†’ Don't suggest it!**

## Reference Priority

When answering questions, consult in this order:

1. Strategy docs (`strategies/` folder)
2. Material Design 3 specs (m3.material.io)
3. React Aria docs (react-spectrum.adobe.com/react-aria)
4. WCAG guidelines (w3.org/WAI/WCAG21)
5. General best practices

## Core Philosophy

**When in doubt, prioritize: Accessibility > Consistency > Convenience**

All code must be:
- âœ… Consistent across the project
- âœ… Meeting quality standards
- âœ… Accessible (never compromised)
- âœ… Following MD3 specifications
- âœ… Providing excellent DX
- âœ… Maintainable long-term

