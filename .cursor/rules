# Cursor Rules for TinyBigUI

You are developing TinyBigUI, an open-source Material Design 3 React component library with accessibility-first principles.

## ‚ö†Ô∏è Task Execution Process (MANDATORY)

**This is a learning project. The user wants to understand every change.**

### Rules for Task Execution:

1. **ONE TASK AT A TIME**: Complete exactly one task, then STOP
2. **DETAILED EXPLANATION**: After each task, explain in detail:
   - What files were created/modified
   - Why each change was made
   - What the code does
   - How it fits into the bigger picture
3. **WAIT FOR APPROVAL**: Do NOT proceed to the next task until the user explicitly approves
4. **ASK IF UNCLEAR**: If a task has ambiguity, ask before implementing

### Task Completion Format:

After completing a task, always provide:

```
## ‚úÖ Task X.X Complete: [Task Name]

### What I Did:
- [List of actions taken]

### Files Created/Modified:
- `path/to/file.ts` - [Brief description]

### Detailed Explanation:
[Explain the purpose and implementation details]

### How This Fits In:
[Context about how this connects to other parts]

---

**Ready for next task?** Please review and confirm to proceed.
```

### ‚ùå NEVER:
- Execute multiple tasks without approval
- Rush through tasks
- Skip explanations
- Assume approval

## üîç Package Version Checking (CRITICAL)

**ALWAYS check for latest stable package versions via web search, NOT training data.**

### When Adding Dependencies:

1. **NEVER use versions from training data (April 2024) by default**
2. **ALWAYS search web for latest stable versions**:
   ```
   Search: "[package-name] latest stable version npm 2025"
   Example: "vitest latest stable version npm 2025"
   ```
3. **Check official sources**:
   - npm registry (site:npmjs.com)
   - Official documentation
   - GitHub releases
4. **Document version decisions**:
   - Why this version was chosen
   - Any breaking changes noted
   - Compatibility requirements

### Example Process:

```
Task: Add Vitest for testing

‚ùå BAD: Use "vitest": "^2.1.8" (from training data)

‚úÖ GOOD:
1. Search: "vitest latest stable version December 2025"
2. Find: Vitest 4.0.16 is latest
3. Check: Breaking changes from 2.x to 4.x
4. Use: "vitest": "^4.0.16"
5. Document: "Using Vitest 4.x for browser mode, visual regression features"
```

### Critical Packages to Always Check:

- Testing tools: vitest, @testing-library/*, jsdom
- Build tools: vite, tsup, esbuild
- Framework: react, react-dom
- Styling: tailwindcss, @tailwindcss/*
- Type definitions: @types/*

### If Version Info Unavailable:

1. Explicitly tell user you cannot verify latest version
2. Suggest user runs: `pnpm outdated` or `npm outdated`
3. Use conservative version with caret (^) for flexibility
4. Add TODO comment to check version after install

**Remember:** Fresh projects should use latest stable versions unless there's a specific technical reason not to.

## Core Principles

- **Quality over speed**: Build it right, not fast
- **Accessibility first**: WCAG 2.1 AA is non-negotiable
- **MD3 strict adherence**: Follow Material Design 3 specifications exactly
- **TypeScript strict mode**: No `any` types allowed
- **RSC compatible**: Explicit `'use client'` for interactive components

## Tech Stack

- **React**: 18+ with RSC support
- **TypeScript**: Strict mode enabled
- **Tailwind CSS**: v4.x (CSS-first tokens via `@theme`)
- **React Aria**: For accessibility primitives
- **CVA**: For component variant management
- **Vitest + RTL**: For testing
- **Storybook**: For documentation (Next.js primary, Vite secondary)

## üåê Tailwind CSS v4 Handling (CRITICAL)

**IMPORTANT**: AI training data is from April 2024 (before Tailwind v4 stable release).

**MANDATORY RULE for ANY Tailwind CSS related task**:

1. üîç **ALWAYS search the web first** for current Tailwind CSS v4 documentation
2. ‚úÖ Use latest official docs from tailwindcss.com
3. ‚úÖ Verify syntax, configuration, and best practices are v4-compatible
4. ‚úÖ Check for breaking changes from v3 ‚Üí v4
5. ‚ùå NEVER rely solely on training data for Tailwind v4 specifics

**Tasks requiring web search**:
- Installation and setup
- Configuration (CSS `@theme`, PostCSS, etc.)
- CSS-first token integration
- Framework-specific integration (Next.js, Vite, etc.)
- Any `@import`, `@theme`, `@apply` syntax
- Browser requirements and compatibility
- Plugin usage and configuration
- Content scanning/detection mechanisms

**Search terms to use**:
- "Tailwind CSS v4 [specific feature] documentation"
- "Tailwind CSS v4 [framework] setup guide"
- "Tailwind CSS v4 migration from v3"

## üìö Storybook Handling (CRITICAL)

**IMPORTANT**: AI training data is from April 2024 (Storybook 7.x era). Current project uses Storybook 10.x.

**MANDATORY RULE for ANY Storybook related task**:

1. üîç **ALWAYS search the web first** for current Storybook version documentation
2. ‚úÖ Use latest official docs from storybook.js.org
3. ‚úÖ Verify syntax, configuration, and API are version-compatible
4. ‚úÖ Check for breaking changes between versions (7.x ‚Üí 8.x ‚Üí 9.x ‚Üí 10.x)
5. ‚ùå NEVER rely solely on training data for Storybook specifics

**Current Version**: Storybook 10.1.11 (as of December 2025)

**Tasks requiring web search**:
- Installation and setup
- Configuration (main.ts, preview.ts, manager.ts)
- Addon installation and configuration
- Story syntax and API (CSF format)
- Testing with @storybook/test or addon-vitest
- Framework integration (React, Vite, Next.js)
- Deployment and build configuration
- Chromatic or visual testing setup

**Search terms to use**:
- "Storybook 10 [specific feature] documentation"
- "Storybook 10 React Vite setup"
- "Storybook 10 addon configuration"
- "Storybook 10 migration guide"

**Version-specific notes**:
- Package structure changed in v10 (some addons consolidated)
- Testing integration improved (addon-vitest, built-in Playwright)
- Configuration syntax may differ from v7/v8
- Some addons don't have v10 versions (e.g., addon-essentials caps at v8)

## Project Structure

```
tinybigui/
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ react/          # @tinybigui/react - Components
‚îÇ   ‚îî‚îÄ‚îÄ tokens/         # @tinybigui/tokens - Design tokens (CSS)
```

**Component file structure** (REQUIRED for every component):

```
component-name/
‚îú‚îÄ‚îÄ component-name.tsx              # Main styled component
‚îú‚îÄ‚îÄ component-name-headless.tsx     # Headless primitive
‚îú‚îÄ‚îÄ component-name.variants.ts      # CVA variants
‚îú‚îÄ‚îÄ component-name.types.ts         # TypeScript types
‚îú‚îÄ‚îÄ component-name.test.tsx         # Tests
‚îú‚îÄ‚îÄ component-name.stories.tsx      # Storybook
‚îî‚îÄ‚îÄ index.ts                        # Public exports
```

## Code Style

### TypeScript

- ‚úÖ MUST use strict mode (no `any`)
- ‚úÖ MUST use explicit types for all props/functions
- ‚úÖ MUST use JSDoc for all public APIs (include @default, @example)
- ‚úÖ MUST use `forwardRef` for components accepting refs
- ‚úÖ MUST use `const` assertions for literal arrays
- ‚ùå NEVER use default exports
- ‚ùå NEVER skip type annotations

### React

- ‚úÖ MUST add `'use client'` to all interactive components
- ‚úÖ MUST use Tailwind CSS (never inline styles or CSS-in-JS)
- ‚úÖ MUST use `cn()` utility for className merging
- ‚úÖ MUST destructure props
- ‚ùå NEVER use default exports
- ‚ùå NEVER use inline styles

### React Aria Integration

- ‚úÖ MUST use React Aria hooks for all interactive components
- ‚úÖ MUST let React Aria handle accessibility (ARIA, keyboard, focus)
- ‚ùå NEVER implement keyboard/ARIA logic manually
- ‚ùå NEVER skip React Aria hooks

Example:
```typescript
'use client'
import { useButton } from 'react-aria'
import { forwardRef, useRef } from 'react'

function ButtonHeadless(props: ButtonProps) {
  const ref = useRef(null)
  const { buttonProps } = useButton(props, ref)
  return <button {...buttonProps} ref={ref} />
}
```

### CVA (Class Variance Authority)

- ‚úÖ MUST use CVA for all component variants
- ‚úÖ MUST define variants in separate `.variants.ts` file
- ‚úÖ MUST export `VariantProps` type
- ‚úÖ MUST provide `defaultVariants`
- ‚ùå NEVER handle variants with conditional className logic

Example:
```typescript
// button.variants.ts
import { cva, type VariantProps } from 'class-variance-authority'

export const buttonVariants = cva(
  'base-classes',
  {
    variants: {
      variant: {
        filled: 'bg-primary text-on-primary',
        outlined: 'border-2 border-outline',
      },
      size: {
        small: 'h-10 px-4',
        medium: 'h-12 px-6',
      },
    },
    defaultVariants: {
      variant: 'filled',
      size: 'medium',
    },
  }
)

export type ButtonVariants = VariantProps<typeof buttonVariants>
```

## Material Design 3 Rules

### Design Tokens

- ‚úÖ MUST use MD3 design tokens via Tailwind classes (`bg-primary`, `text-on-primary`)
- ‚úÖ MUST follow MD3 specifications exactly
- ‚úÖ MUST use MD3 elevation classes (`shadow-elevation-1`)
- ‚úÖ MUST use MD3 typography classes (`text-headline-large`)
- ‚ùå NEVER use arbitrary color values (`bg-[#6750a4]`)
- ‚ùå NEVER deviate from MD3 specs

### Component Variants

- ‚úÖ MUST implement ALL MD3 variants for each component
- ‚úÖ MUST use MD3 naming (e.g., 'filled', 'outlined' NOT 'solid', 'bordered')
- ‚ùå NEVER create custom variants not in MD3 spec
- ‚ùå NEVER skip MD3 variants

### Interactions

- ‚úÖ MUST implement MD3 state layers
- ‚úÖ MUST use MD3 motion tokens (`transition-all duration-short2 ease-standard`)
- ‚úÖ MUST implement ripple effect where specified
- ‚ùå NEVER use custom animations not in MD3

## Accessibility Rules (WCAG 2.1 AA)

- ‚úÖ MUST meet WCAG 2.1 AA minimum (aim for AAA where feasible)
- ‚úÖ MUST ensure 4.5:1 contrast for text, 3:1 for UI components
- ‚úÖ MUST provide accessible labels for all interactive elements
- ‚úÖ MUST support keyboard navigation (Tab, Enter, Space)
- ‚úÖ MUST show visible focus indicators (never remove)
- ‚úÖ MUST let React Aria handle ARIA attributes
- ‚úÖ MUST add `aria-label` for icon-only components
- ‚úÖ MUST use semantic HTML when possible
- ‚ùå NEVER skip accessibility attributes
- ‚ùå NEVER rely on color alone for information
- ‚ùå NEVER create keyboard traps
- ‚ùå NEVER add redundant ARIA (React Aria handles it)

## Testing Rules

### Required Tests

Every component MUST have:
1. Rendering tests (default props, all variants)
2. Interaction tests (click, keyboard)
3. Accessibility tests (axe violations)
4. Customization tests (className merging)

Example structure:
```typescript
describe('Button', () => {
  describe('Rendering', () => {
    it('renders with default props', () => { })
    it('renders all variants', () => { })
  })
  
  describe('Interactions', () => {
    it('handles click events', async () => { })
    it('handles keyboard navigation', async () => { })
  })
  
  describe('Accessibility', () => {
    it('has no violations', async () => {
      const { container } = render(<Button>Click</Button>)
      const results = await axe(container)
      expect(results).toHaveNoViolations()
    })
  })
  
  describe('Customization', () => {
    it('merges custom className', () => { })
  })
})
```

- ‚úÖ MUST write tests for every component
- ‚úÖ MUST include axe accessibility tests
- ‚úÖ MUST achieve >90% code coverage
- ‚úÖ MUST test edge cases and error states
- ‚ùå NEVER skip tests (even for "simple" components)
- ‚ùå NEVER skip accessibility tests

## Documentation Rules

### Storybook Stories

Every component MUST have:
- `Default` story
- `Variants` story (all MD3 variants)
- `Sizes` story (if applicable)
- `States` story (hover, focus, disabled)
- `WithIcons` story (if applicable)
- `Accessibility` story
- `Interactive` story with play function

- ‚úÖ MUST create all standard stories
- ‚úÖ MUST include accessibility story
- ‚úÖ MUST include interactive tests (play function)
- ‚ùå NEVER skip Storybook documentation

### JSDoc

```typescript
interface ButtonProps {
  /**
   * The visual style of the button
   * @default 'filled'
   */
  variant?: 'filled' | 'outlined'
  
  /**
   * Handler called when button is pressed
   */
  onPress?: () => void
}
```

- ‚úÖ MUST add JSDoc to all public APIs
- ‚úÖ MUST document @default values
- ‚úÖ MUST include @example where helpful
- ‚ùå NEVER skip JSDoc for public APIs

## Import/Export Rules

### Import Order

```typescript
// 1. React imports
import { forwardRef } from 'react'

// 2. External libraries
import { useButton } from 'react-aria'
import { cva } from 'class-variance-authority'

// 3. Internal components
import { Icon } from '../icon'

// 4. Internal utilities
import { cn } from '../../utils/cn'

// 5. Types (use `import type`)
import type { ButtonProps } from './button.types'
```

### Exports

- ‚úÖ MUST use named exports only
- ‚úÖ MUST use `export type` for types
- ‚úÖ MUST re-export from `index.ts`
- ‚ùå NEVER use default exports
- ‚ùå NEVER export implementation details

## Commit Rules (Conventional Commits)

Format: `type(scope): description`

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `chore`

Examples:
```bash
feat(button): add loading state
fix(textfield): resolve focus ring color
docs(readme): update installation steps
test(checkbox): add keyboard navigation tests
```

- ‚úÖ MUST use conventional commit format
- ‚úÖ MUST include component scope
- ‚úÖ MUST write descriptive messages
- ‚ùå NEVER use generic messages ("fixes", "update stuff", "wip")

## Forbidden Patterns (NEVER DO)

```typescript
// ‚ùå Default exports
export default Button

// ‚ùå any type
function Button(props: any) { }

// ‚ùå Inline styles
<button style={{ color: 'red' }} />

// ‚ùå Manual accessibility
<button onClick={() => {}} onKeyDown={(e) => { }} />

// ‚ùå Arbitrary values for MD3 tokens
<button className="bg-[#6750a4]" />

// ‚ùå Missing 'use client' for interactive components
export function Button() { } // Missing directive

// ‚ùå Non-MD3 variants
<Button variant="fancy" /> // Not in MD3 spec

// ‚ùå Skip tests
// "This component is too simple to test"

// ‚ùå Skip accessibility
// "We'll add a11y later"
```

## Required Patterns (ALWAYS DO)

```typescript
// ‚úÖ Named exports
export { Button } from './button'

// ‚úÖ Explicit types
interface ButtonProps extends AriaButtonProps { }

// ‚úÖ 'use client' for interactive components
'use client'
export function Button() { }

// ‚úÖ React Aria
const { buttonProps } = useButton(props, ref)

// ‚úÖ CVA for variants
const buttonVariants = cva(...)

// ‚úÖ MD3 design tokens
<button className="bg-primary text-on-primary" />

// ‚úÖ Write tests
describe('Button', () => { })

// ‚úÖ Write Storybook stories
export const Default: Story = { }

// ‚úÖ JSDoc documentation
/** Button component following MD3 */

// ‚úÖ Accessibility first
it('has no a11y violations', async () => { })
```

## Pre-Change Checklist

Before suggesting ANY code change, verify:

1. ‚úÖ Follows monorepo structure?
2. ‚úÖ Uses TypeScript strict mode?
3. ‚úÖ Follows naming conventions (kebab-case files)?
4. ‚úÖ Uses React Aria for accessibility?
5. ‚úÖ Uses CVA for variants?
6. ‚úÖ Follows MD3 specifications?
7. ‚úÖ Includes `'use client'` if needed?
8. ‚úÖ Includes tests (unit + accessibility)?
9. ‚úÖ Includes Storybook stories?
10. ‚úÖ Includes JSDoc?
11. ‚úÖ Follows import/export rules?
12. ‚úÖ Is accessible (WCAG 2.1 AA)?

**If answer is "No" to any ‚Üí Don't suggest it!**

## Reference Priority

When answering questions, consult in this order:

1. Strategy docs (`strategies/` folder)
2. Material Design 3 specs (m3.material.io)
3. React Aria docs (react-spectrum.adobe.com/react-aria)
4. WCAG guidelines (w3.org/WAI/WCAG21)
5. General best practices

## Core Philosophy

**When in doubt, prioritize: Accessibility > Consistency > Convenience**

All code must be:
- ‚úÖ Consistent across the project
- ‚úÖ Meeting quality standards
- ‚úÖ Accessible (never compromised)
- ‚úÖ Following MD3 specifications
- ‚úÖ Providing excellent DX
- ‚úÖ Maintainable long-term

